#!/bin/bash

# Copyright 2015 Olivier van Helden <olivier@van-helden.net>
# Released under GNU Affero GPL v3.0 license
#    http://www.gnu.org/licenses/agpl-3.0.html

LogDir=/opt/opensim/var/logs

DELAY=60
shutdownDelay=120
shutdownWarnings=3
DEBUG=yes

# End of user configurable data

BASEDIR=$(dirname $(dirname $(readlink -f "$0")))
LIB=$BASEDIR/lib
. $LIB/os-helpers || exit 1
. $LIB/bash-helpers/ini_parser 2>/dev/null || end 1 "Missing ini_parser library"

trap 'rm -f $TMP*' EXIT

HELP="
      -s start
      -h display this help
      -v verbose mode
      -q quiet mode

sorry, helpman is in a minimalist mood"


OPTS="shvq"
while getopts $OPTS PARAM
do
    case $PARAM in
	"?")
	    ERROR=1
	        ;;
	-)
	    case $OPTARG in
		help)
		    help
		    end
		    ;;
		*)
		    printf "$PGM: illegal option -- $OPTARG"
#    ERROR=1
	    esac
	    ;;
	s)
	    action=start
	    ;;
	h)
	    help
	    end
	    ;;
	v)
	    STDERR="&1"
            DEBUG=yes
	    QUIET=no
	    ;;
	q)
	    STDOUT="/dev/null"
	    QUIET=yes
	    DEBUG=no
	    ;;
	*)
	    VALUES="$VALUES $PARAM"
	    LASTVAL=$PARAM
    esac

done 2>/dev/null
shift `expr $OPTIND - 1`

#ini_parser="$(which ini_parser)"
#[ -n "$ini_parser" ] || end 1 no ini parser
#log "ini_parser: $ini_parser"
. "$(which ini_parser)" || end 2 could not launch ini parser

realpath() {
readlink -f "$@" 2>/dev/null && return
cd "$@" 2>/dev/null && pwd -P && return
}

startSim() {
    unset IFS
    for arg in $@
    do
	ls -d "$arg" 2>/dev/null | grep -q "\.ini$" \
	    && { inifile=$arg; instance=$(basename $arg .ini | tr "[:upper:]" "[:lower:]"); } \
	    || { instance=$(echo $arg | tr "[:upper:]" "[:lower:]"); inifile=$(buildIni "$instance"); }

	[ ! -e "$inifile" ] && continue

	instance=$(echo "$instance" | sed "s/[^a-zA-Z]*//g")

	log "$instance ($ini)"

	screen -ls | egrep -q "[0-9][0-9]*\.$instance[[:blank:]]"
	if [ $? -eq 0 ]
		then
		log 1 "An instance of $instance is already running"
		continue
	fi

	for default in $(echo "$ETCPATH:" | sed "s|/*:|/default.ini |g")
	do
	    [ -f "$default" ] || continue
	    ini_parser "$default" || continue
	    ini_section_Const 2>/dev/null
	    ini_section_Startup 2>/dev/null
	    ini_section_Launch 2>/dev/null
	done
	log "BinDir: $BinDir"
	log extracting launch info from $inifile file

	cat "$inifile" | sed '/\[Const]/,/^\[/!d' | sed "$ d" > $TMP.ini
	cat "$inifile" | sed '/\[Launch]/,/^\[/!d' | sed "$ d" >> $TMP.ini
	cat "$inifile" | sed '/\[Startup]/,/^\[/!d' | sed "$ d" >> $TMP.ini
	log reading $inifile file
	ini_parser "$TMP.ini" || continue
	# ini_parser "$inifile" || continue
	#2>/dev/null || continue
	log reading section Launch

	# ini_section_Startup 2>/dev/null
	ini_section_Const 2>/dev/null
	ini_section_Launch 2>/dev/null
	log "starting $instance with $inifile"
	cd $BinDir 2>/dev/null || log 2 $instance Cannot cd to $BinDir
	log "BinDir $BinDir"
	[ -f $Executable ] || log 3 Executable $Executable not found

        [ ! "$LogFile" ] && LogFile="$logfile"
        [ ! "$LogFile" ] && LogFile="$LogDir/$instance.log"

	cmd="mono $Executable -inifile='$inifile'"
	if [ $Executable = "Robust.exe" ]
	then
	    [ ! "$ConsolePrompt" ] && ConsolePrompt="Robust ($instance) "
	    cmd="$cmd -logfile='$LogFile' -prompt '$ConsolePrompt'"
	else
	    [ ! "$ConsolePrompt" ] && ConsolePrompt="$instance (\R) "
        fi
	#LogConfig=$(echo "$inifile" | sed -e "s/\.ini$/.LogConfig/" -e "s%/[a-z]*-enabled/%/%")
        #		LogConfig=${inifile/.ini/.LogConfig}
	echo "LogConfig $LogConfig"
	if [ ! -f "$LogConfig" ]
	then
            ExecName=$(basename $Executable .exe)
            sed -e "s|[a-zA-Z0-9\./_-]*/*$ExecName.log|$LogDir/$instance.log|" \
                -e "s|[a-zA-Z0-9\./_-]*/*${ExecName}Stats.log|$LogDir/${instance}.Stats.log|" \
                $BinDir/$Executable.config > $LogConfig
	    cd /opt/opensim/var/data/config
	    ln -s $LogConfig 2>/dev/null
            log created LogConfig file $LogConfig from core model $BinDir/$Executable.config
        fi

	if [ -f "$LogConfig" ]
	then
	    cmd="$cmd -logconfig=$LogConfig"
	fi
	echo "$cmd"

	touch $TMP.wait
	log "launching $instance "
	log "$cmd"
	eval "screen -S $instance -d -m $cmd"
	screen -ls | egrep "[0-9][0-9]*\.$instance[[:blank:]]"


        TAILTIMEOUT=120
        log "logfile: $LogFile"
        echo timeout $TAILTIMEOUT tailgrep "neighbours.*region.*is up" $LogFile

        timeout $TAILTIMEOUT tailgrep "neighbours.*region.*is up" $LogFile \
            && echo "At least one region started" \
                || echo "Startup still going on after $TAILTIMEOUT seconds, check again later"

	# echo screen -S robust -d -m mono Robust.exe -inifile='/etc/opensim/robust-enabled/robust.ini' -logfile='/var/log/opensim/Robust.HG.log' -prompt 'Robust (robust) '

	# screen -S $instance -d -m $cmd || log $? "screen error"
	# sleep 1
	# log "still launching"
	# sleep 1
	# sleep 1
	# continue
	# 	sleep 1
	# 	printf "launching\n"
	# 	sleep 1
	# 	screen -ls | egrep "[0-9][0-9]*\.$instance[[:blank:]]"
	# 	sleep 1
    done
}

stopSim() {
  [ "$1" ] && sims=$1 || sims=$(enabledIni opensim robust)
  for sim in $sims
  do
    simName=$(ini2Name $sim)
    log notiy users in $simName
    warnDelay=$(($shutdownDelay / $shutdownWarnings))
    warn=0
    [ $shutdownDelay -le 10 ] && shutdownWarnings=1
    [ $shutdownDelay -eq 0 ] && shutdownWarnings=0
    while [ $warn -lt $shutdownWarnings ]
    do
      remaining=$(($shutdownDelay - $warn * $warnDelay))
      log " $remaining seconds left"
      osConsole $simName "alert Attention: this simulator will be restarted in $remaining seconds. Please teleport to another region to avoid being disconnected."
      sleep $warnDelay
      warn=$(($warn + 1))
    done
    osConsole $simName "alert Shutting down now."
    log shutting down $simName
    osConsole $simName shutdown
    screen -x $simName
  done
}

restartSim() {
  [ "$1" ] && sims=$1 || sims=$(enabledIni robust opensim)
  for sim in $sims
  do
    simName=$(ini2Name $sim)
    stopSim $simName
    startSim $sim
  done
}

ini2Name() {
  [ ! "$1" ] && return "no-name"
  ini=$1
  [ -f "$1" ] && name=$(egrep "^[[:blank:]]SimName *=" $ini)
  [ ! $name ] && name=$(basename $ini .ini | tr [:upper:] [:lower:])
  echo $name
}

enabledIni() {
  [ "$1" ] && types=$1 || types="robust opensim"
  for type in $types
  do
    case $type in
      robust)
      ls "$etc"/robust.d/*.ini 2>/dev/null | sort -n
      ls "$etc"/robust-enabled/*.ini 2>/dev/null | sort -n
      ;;
      opensim)
      ls "$etc"/opensim.d/*.ini 2>/dev/null | sort -n
      ls "$etc"/simulators-enabled/*.ini 2>/dev/null | sort -n
      ;;
    esac
  done
}


buildIni() {
    unset ini
    sim="$@"
    ini=$(
    IFS=":"
    for etc in $ETCPATH
    do
	log "looking in $etc"
	(
	    ls "$etc"/*.d/*.ini 2>/dev/null
	    ls "$etc"/*-enabled/*.ini 2>/dev/null
	) | grep -i "/$sim.ini$" && break
#	lookup="$etc/simulators-enabled/$sim.ini"
#	log "looking for $lookup"
#	[ -f "$lookup" ] || continue
#	log "gotcha $lookup"
#	ini="$lookup"
#	break
    done | head -1
    )

    if [ ! -n "$ini" ]
    then
	log 1 "no ini file found for $sim"
	continue
    fi
    log "$sim ini $ini"
    echo "$ini"
}

cleanpath() {
    IFS=:
    printf "" > $TMP.realpath
    for etc in $@
    do
	real=$(realpath "$etc")
#	echo path $etc >&2
#	echo real $real >&2
	[ ! -d "$real" ] && continue
	grep -q "^$real$" $TMP.realpath && continue
	echo "$real" >> $TMP.realpath
    done
    unset IFS

    newpath=$(cat $TMP.realpath | tr "\n" ":" | sed "s/:$//")
    rm "$TMP.realpath"
    echo $newpath
}

status() {
    ps -C mono -o  pid,uname,pcpu,pmem,rss,args --sort=-pcpu,pmem \
	| sed "s/mono.*inifile=//" \
	| sed "s/-log.*//" \
	| tee $TMP.usage
    ucpu=0
    umem=0
    cat $TMP.usage | grep -v PID \
	| awk '{count+=1; cpu += $3; mem += $4; rss += $5} END {print "TOTAL\n" count "\tprocesses\n" cpu "\t% cpu\n" mem "\t% mem\n" rss "\trss"}'
    return
    #e | grep -v "PID" | cut -f 1 | paste -sd+
    printf "" | sed "s/\.//g"  \
	| while read pid user cpu mem command
	  do
	      ucpu=$(($ucpu + $cpu))
	      umem=$(($umem + $mem))
	  done
    echo "cpu usage: $ucpu"
    echo "mem usage: $umem"
}

B="[[:blank:]]*"

getRobustPath() {
    IFS=:
    for etc in $ETCPATH
    do
	unset IFS
	for ini in $(
	    egrep -li "^[[:blank:]]*Executable[[:blank:]]*=[[:blank:]]*Robust.exe[[:blank:]]*$" "$etc"/*-enabled/*.ini 2>/dev/null | sort -n
	    ls "$etc"/default.ini 2>/dev/null
	)
	do
	    egrep "^${B}BinDir${B}=" "$ini";
	done
    done | head -1 | sed "s/^[[:blank:]]*BinDir[[:blank:]]*=[[:blank:]]*//"
    unset IFS
}

ETCPATH=$(cleanpath "$ETCPATH")

#getRobustPath
#end

log looking in $ETC

IFS=":"
for etc in $ETC $ETCPATH
do
    folder=$(realpath "$etc")
    [ "$folder" ] || continue
    echo ":$LOOKUP:" | grep -q ":$folder:" && log "ignoring duplicate $etc" && continue
    LOOKUP="$LOOKUP:$folder" && continue
done
unset IFS
LOOKUP="$(echo $LOOKUP | sed "s/^:*//")"

if [ ! -n "$LOOKUP" ]
then
    end 1 "No valid folder found in $ETCPATH"
fi
ETCPATH=$LOOKUP
log "ETCPATH: $ETCPATH"

case "$1" in
  "start")
  action=$1
  shift
  ;;
  "stop")
  action=$1
  shift
  [ "$1" = "now" ] && shutdownDelay=0 && shift
  stopSim "$@"
  ;;
  "restart")
  action=$1
  shift
  [ "$1" = "now" ] && shutdownDelay=0 && shift
  restartSim "$@"
  ;;
  "status")
	action=$1
  shift
	;;
esac

case $action in
    status)
	status
	;;
	start)
	if [ -n "$1" ]
	then
	    startSim "$@"
	else
	    log Starting all
	    IFS=:
	    for etc in $ETCPATH
	    do
		unset IFS
		for ini in $(
      ls "$etc"/robust.d/*.ini 2>/dev/null | sort -n
      ls "$etc"/robust-enabled/*.ini 2>/dev/null | sort -n
      ls "$etc"/opensim.d/*.ini 2>/dev/null | sort -n
			ls "$etc"/simulators-enabled/*.ini 2>/dev/null | sort -n
			)
		do
		    [ -f "$TMP.wait" -a "$DELAY" ] && read -p "waiting $DELAY seconds between instances " -t $DELAY
		    rm -f "$TMP.wait"
		    startSim "$ini"
		done
	    done
	    unset IFS
	fi
	;;
    connections)
	;;
esac
